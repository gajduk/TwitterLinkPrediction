package mk.edu.manu.cs.algorithm;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;

import mk.edu.manu.cs.graph2.Edge;
import mk.edu.manu.cs.graph2.Graph;
import mk.edu.manu.cs.graph2.Node;

public class RandomWalkClustering {
	private Graph g;
	private double resilience;
	private int K;
	private boolean hasConverged = false;
	private int currStability = 0;
	public int maxStability = 0;
	public int maxStabilityIter = -1;
	public int iter = 0;
	public HashMap<Integer, Integer> maxStabilityPartition;
	private double alpha;

	public static final double CONVERGENCE = 1E-5;

	public RandomWalkClustering(Graph g, int K, double resilience,double alpha) {
		this.g = g;
		this.K = K;
		this.alpha = alpha;
		this.resilience = resilience;

		for (Node node : g.nodes) {
			HashMap<Integer, Double> cmap = new HashMap<Integer, Double>();
			node.putAttr("cmap", cmap);
			cmap.put(node.id, 1.0);
			HashMap<Integer, Double> newcmap = new HashMap<Integer, Double>();
			node.putAttr("newcmap", newcmap);
			node.putAttr("maxcolorid", node.id);
		}
	}

	public boolean hasConverged() {
		return this.hasConverged;
	}

	@SuppressWarnings("unchecked")
	public void iterate() {
		iter++;
		// System.out.println("Resilience: " + resilience);
		// System.out.println("Convergence factor: " + CONVERGENCE);
		// System.out.println("iter\tNc\tStab1\tStab2\tclusterID(sizes)");
		boolean converged = true;
		boolean change = false;
		for (Node node : g.nodes) {
			// update the colors of the current node
			HashMap<Integer, Double> newcmap = (HashMap<Integer, Double>) node
					.getAttr("newcmap");
			double prob = (1.0 - resilience) / node.outEdges.size();
			newcmap.put(node.id, resilience);
			for (Edge edge : node.outEdges) {
				HashMap<Integer, Double> friendCmap = (HashMap<Integer, Double>) edge.dest
						.getAttr("cmap");
				// update the color map using friend's color map
				for (Integer colorid : friendCmap.keySet()) {
					if (!newcmap.containsKey(colorid)) {
						newcmap.put(colorid, 0.0);
					}
					newcmap.put(colorid, newcmap.get(colorid) + prob
							* friendCmap.get(colorid));
				}
			}
			// check for convergence
			HashMap<Integer, Double> cmap = (HashMap<Integer, Double>) node
					.getAttr("cmap");
			double delta = 0;
			for (Integer key : newcmap.keySet()) {
				double a = 0.0, b = newcmap.get(key);
				if (cmap.containsKey(key)) {
					a = cmap.get(key);
				}
				delta = Math.max(delta, Math.abs(a - b));
			}
			if (delta > CONVERGENCE) {
				converged = false;
			}
		}
		HashSet<Integer> colors = new HashSet<Integer>();
		HashMap<Integer, Integer> partition = new HashMap<Integer, Integer>();
		// update the colors of all nodes (top K) and replace colormaps
		for (Node node : g.nodes) {
			HashMap<Integer, Double> cmap = (HashMap<Integer, Double>) node
					.getAttr("cmap");
			cmap.clear();
			node.putAttr("cmap", node.getAttr("newcmap"));
			node.putAttr("newcmap", cmap);
			cmap = (HashMap<Integer, Double>) node.getAttr("cmap");
			List<Entry<Integer, Double>> list = new ArrayList<Entry<Integer, Double>>(
					cmap.entrySet());
			Collections.sort(list, new Comparator<Entry<Integer, Double>>() {
				public int compare(Entry<Integer, Double> o1,
						Entry<Integer, Double> o2) {
					if (o2.getValue() > o1.getValue()) {
						return 1;
					} else if (o2.getValue() < o1.getValue()) {
						return -1;
					} else {
						return 0;
					}
				}
			});
			int topColor = list.get(0).getKey();
			colors.add(topColor);
			if (node.getAttr("maxcolorid") != list.get(0).getKey()) {
				change = true;
				node.putAttr("maxcolorid", list.get(0).getKey());
				partition.put(node.id, list.get(0).getKey());
			}
			if (K < list.size()) {
				// spread only the top k
				double sum = 0.0;
				for (int i = 0; i < list.size(); i++) {
					if (i < K) {
						sum += list.get(i).getValue();
					} else {
						cmap.remove(list.get(i).getKey());
					}
				}
				for (int i = 0; i < Math.min(list.size(), K); i++) {
					cmap.put(list.get(i).getKey(), list.get(i).getValue() / sum);
				}
			}
		}
		if (!change) {
			currStability++;
			if (currStability > maxStability) {
				maxStability = currStability;
				maxStabilityIter = iter;
				maxStabilityPartition = partition;
			}
		} else {
			currStability = 0;
		}
		System.out.println(iter + "\t" + colors.size());
		if (converged) {
			hasConverged = true;
		}

		Node node = g.nodes.get(0);
		HashMap<Integer, Double> cmap = (HashMap<Integer, Double>) node
				.getAttr("cmap");
		for (Integer key : cmap.keySet()) {
			System.out.print(key + ":" + cmap.get(key) + "|");
		}
		System.out.println();
		return;
	}
}
