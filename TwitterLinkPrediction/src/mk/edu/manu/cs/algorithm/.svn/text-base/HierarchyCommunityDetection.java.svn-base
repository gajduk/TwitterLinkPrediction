package mk.edu.manu.cs.algorithm;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import mk.edu.manu.cs.datasets.Files;
import mk.edu.manu.cs.graph2.Edge;
import mk.edu.manu.cs.graph2.Graph;
import mk.edu.manu.cs.graph2.Node;

public class HierarchyCommunityDetection {
	public static int clustering(Graph g) throws NumberFormatException,
			IOException, InterruptedException {
		return clustering(g, false, new long[10]);
	}

	public static int clustering(Graph g, boolean print, long[] executionTimes)
			throws NumberFormatException, IOException, InterruptedException {
		long start, end;
		int i = 0;
		start = System.currentTimeMillis();
		calcEdgeScore(g);
		end = System.currentTimeMillis() - start;
		executionTimes[i++] = end;
		if (print)
			System.out.println("1st pass(edge score):" + end + "ms");

		start = System.currentTimeMillis();
		calcNodeRandomWalkScore(g);
		// LeaderProbability(g);
		end = System.currentTimeMillis() - start;
		executionTimes[i++] = end;
		if (print)
			System.out.println("1st pass(node score):" + end + "ms");

		// // sorting the nodes by score
		// start = System.currentTimeMillis();
		// SortNodesByAttribute(g, "score", true);
		// end = System.currentTimeMillis() - start;
		// System.out.println("2nd pass (sorting):" + end + "ms");

		// calcParentScores(g);

		start = System.currentTimeMillis();
		// int nleaders = calcLeaders(g);
		ArrayList<ArrayList<Node>> groups = calcLeaders(g, print);
		end = System.currentTimeMillis() - start;
		executionTimes[i++] = end;
		if (print)
			System.out.println("2nd pass (leaders):" + end + "ms");

		start = System.currentTimeMillis();
		//double[] params = calcColors(g, groups, print);
		calcColors2(g, groups, print);
		end = System.currentTimeMillis() - start;
		executionTimes[i++] = end;
//		for(double param : params)
//			executionTimes[i++] = Math.round(param);
		if (print)
			System.out.println("2nd pass (coloring):" + end + "ms");

		return groups.size();// nleaders;
	}

	public static void checkIfParentsHaveTheSameColor(Graph g, int groupsSize) {
		int count = 0;
		for (Node node : g.nodes) {
			double maxInf = 0.0;
			ArrayList<Node> parents = new ArrayList<Node>();
			for (Edge edge : node.outEdges) {
				if ((Double) edge.getAttr("w") > maxInf) {
					// its influence to the neighbor
					maxInf = (Double) edge.getAttr("w");
					parents = new ArrayList<Node>();
					parents.add(edge.dest);
				} else if (Math.abs((Double) edge.getAttr("w") - maxInf) < 1E-5)
					parents.add(edge.dest);
			}
			double[] cmap = (double[]) node.getAttr("cmap");
			boolean isIt = false;
			for (Node node2 : parents) {
				double[] cmap2 = (double[]) node2.getAttr("cmap");
				boolean isIt2 = true;
				for (int i = 0; i < groupsSize; i++) {
					if (cmap[i] != cmap2[i]) {
						isIt2 = false;
						break;
					}
				}
				if (isIt2) {
					isIt = true;
					break;
				}
			}
			if (!isIt) {
				count++;
				System.out.println("node irregular:" + node.id + " "
						+ node.getAttr("label"));
			}
		}
		System.out.println("count: " + count);
	}

	private static ArrayList<ArrayList<Node>> calcLeaders(Graph g) {
		return calcLeaders(g, true);
	}

	private static ArrayList<ArrayList<Node>> calcLeaders(Graph g, boolean print) {
		List<Node> roots = new ArrayList<Node>();

		// old code
		// for (Node node : g.nodes) {
		// double str = 0;
		// for (Edge edge : node.outEdges) {
		// str += (Double) edge.getAttr("w")
		// * (Double) edge.dest.getAttr("score");
		// }
		// node.putAttr("str", str);
		// }

		// determining every node's parents
		for (Node node : g.nodes) {
			double maxInf = 0.0;
			ArrayList<Node> parents = new ArrayList<Node>();
			for (Edge edge : node.outEdges) {
				if ((Double) edge.getAttr("w") > maxInf) {
					// its influence to the neighbor
					maxInf = (Double) edge.getAttr("w");
					parents = new ArrayList<Node>();
					parents.add(edge.dest);
				} else if (Math.abs((Double) edge.getAttr("w") - maxInf) < 1E-5)
					parents.add(edge.dest);
			}
			node.putAttr("parents", parents);
		}

		for (Node node : g.nodes) {
			boolean amIRoot = true;
			ArrayList<Node> parents = (ArrayList<Node>) node.getAttr("parents");
			for (int i = 0; i < parents.size(); i++) {
				try {
					if ((Double) node.getEdge(parents.get(i)).getAttr("w")
							* (Double) parents.get(i).getAttr("score") > (Double) parents
							.get(i).getEdge(node).getAttr("w")
							* (Double) node.getAttr("score")) {
						amIRoot = false;
						break;
					}
				} catch (Exception ex) {// if directed and no return edge
					amIRoot = false;
					break;
				}
			}
			if (amIRoot) {
				roots.add(node);
				node.putAttr("isRoot", true);
				node.putAttr("parent", node);
				String label = (String) node.getAttr("label");
				if (label == null)
					label = node.id + "";
				if (print)
					System.out.println(label + " is root!");
			}
		}

		// remove the non-roots from the root-nodes' parents
		for (int i = 0; i < roots.size(); i++) {
			Node node = roots.get(i);
			ArrayList<Node> parents = (ArrayList<Node>) node.getAttr("parents");
			ArrayList<Node> nonparents = new ArrayList<Node>();
			for (Node node2 : parents) {
				if (node2.getAttr("isRoot") == null)
					nonparents.add(node2);
			}
			for (Node node2 : nonparents) {
				parents.remove(node2);
			}
			node.putAttr("parents", parents);
		}

		ArrayList<ArrayList<Node>> groups = new ArrayList<ArrayList<Node>>();
		for (int i = 0; i < roots.size(); i++) {
			Node node = roots.get(i);
			ArrayList<Node> parents = (ArrayList<Node>) node.getAttr("parents");
			for (int j = 0; j < parents.size(); j++) {
				Node node2 = parents.get(j);
				ArrayList<Node> parents2 = (ArrayList<Node>) node2
						.getAttr("parents");
				boolean sub = true;
				for (int k = 0; k < parents2.size(); k++) {
					if (!parents.contains(parents2.get(k)) && (j != k)) {
						sub = false;
						break;
					}
				}
				// if all of my parents are also parents to someone else
				// in the full-mesh case - merge them, in the ring case - don't
				// merge them
				if (sub) {
					boolean found = false;
					for (int k = 0; k < groups.size(); k++) {
						if (groups.get(k).contains(node)) {
							boolean found2 = false;
							int l = 0;
							for (; l < groups.size(); l++) {
								if (groups.get(l).contains(node2)) {
									found2 = true;
									break;
								}
							}
							if (found2) {
								if (l != k) {
									// merge groups
									for (int m = 0; m < groups.get(l).size(); m++) {
										groups.get(k).add(groups.get(l).get(m));
									}
									groups.remove(l);
								}
							} else
								groups.get(k).add(node2);
							found = true;
							break;
						}
					}
					if (!found) {
						boolean found2 = false;
						for (int k = 0; k < groups.size(); k++) {
							if (groups.get(k).contains(node2)) {
								groups.get(k).add(node);
								found2 = true;
								break;
							}
						}
						if (!found2) {
							ArrayList<Node> group = new ArrayList<Node>();
							group.add(node);
							group.add(node2);
							groups.add(group);
						}
					}
				}
			}
			boolean found = false;
			for (int k = 0; k < groups.size(); k++) {
				if (groups.get(k).contains(node)) {
					found = true;
					break;
				}
			}
			if (!found) {
				ArrayList<Node> group = new ArrayList<Node>();
				group.add(node);
				groups.add(group);
			}
		}

		if (print)
			System.out.println("Number of communities: " + groups.size());

		return groups;
	}

	private static int calcLeadersNew(Graph g) {
		List<Node> roots = new ArrayList<Node>();
		for (Node node : g.nodes) {
			double str = 0;
			for (Edge edge : node.outEdges) {
				str += (Double) edge.getAttr("w")
						* (Double) edge.dest.getAttr("score");
			}
			node.putAttr("str", str);
		}

		for (Node node : g.nodes) {
			double maxInf = 0.0;
			double maxScore = 0.0;
			Node nn = null;
			ArrayList<Node> parents = new ArrayList<Node>();
			for (Edge edge : node.outEdges) {
				if ((Double) edge.getAttr("w") > maxInf) {
					// its influence to the neighbor
					maxInf = (Double) edge.getAttr("w");
					// maxScore = (Double) edge.dest.getAttr("score");
					// nn = edge.dest;
					parents = new ArrayList<Node>();
					parents.add(edge.dest);
				} else if (Math.abs((Double) edge.getAttr("w") - maxInf) < 1E-5) {
					// if ((Double) edge.dest.getAttr("score") > maxScore) {
					// maxScore = (Double) edge.dest.getAttr("score");
					// nn = edge.dest;
					// }
					parents.add(edge.dest);
				}
			}
			node.putAttr("parents", parents);
			// node.putAttr("parent", nn);
		}
		for (Node node : g.nodes) {
			boolean amIRoot = true;
			ArrayList<Node> parents = (ArrayList<Node>) node.getAttr("parents");
			for (int i = 0; i < parents.size(); i++) {
				// if((Double)parents.get(i).getAttr("score")>(Double)node.getAttr("score")){
				// amIRoot = false;
				// break;
				// }
				// if((Double)node.getEdge(parents.get(i)).getAttr("w")>(Double)parents.get(i).getEdge(node).getAttr("w")){
				// amIRoot = false;
				// break;
				// }
				if ((Double) node.getEdge(parents.get(i)).getAttr("w")
						* (Double) parents.get(i).getAttr("score") > (Double) parents
						.get(i).getEdge(node).getAttr("w")
						* (Double) node.getAttr("score")) {
					amIRoot = false;
					break;
				}
			}
			// if ((Double) ((Node) node.getAttr("parent")).getAttr("score") >
			// (Double) node
			// .getAttr("score"))
			// amIRoot = false;
			// else {
			// // if (node.id != ((Node) ((Node) node.getAttr("parent"))
			// // .getAttr("parent")).id)
			// // amIRoot = false;
			// // amIRoot = true;
			// }
			if (amIRoot) {
				roots.add(node);
				node.putAttr("isRoot", true);
				node.putAttr("parent", node);
				String label = (String) node.getAttr("label");
				if (label == null)
					label = node.id + "";
				System.out.println(label + " is root!");
			}
		}

		/*
		 * for(int i=0;i<roots.size()-1;i++) { for(int j=i+1;j<roots.size();j++)
		 * { Node node1 = roots.get(i); Node node2 = roots.get(j); Edge edge =
		 * new Edge(node1,node2);
		 * 
		 * roots.get(i).outEdges.add(arg0) } }
		 */
		System.out.println("Number of leaders: " + roots.size());

		return roots.size();
	}

	private static int calcLeadersOld(Graph g) {
		List<Node> roots = new ArrayList<Node>();
		for (Node node : g.nodes) {
			double str = 0;
			for (Edge edge : node.outEdges) {
				str += (Double) edge.getAttr("w")
						* (Double) edge.dest.getAttr("score");
			}
			node.putAttr("str", str);
		}

		for (Node node : g.nodes) {
			boolean amIRoot = true;
			for (Edge edge : node.outEdges) {
				// if ((Double) edge.getAttr("w")
				// * (Double) edge.dest.getAttr("score") >= (Double) node
				// .getAttr("str") / node.outEdges.size()) {
				if ((Double) edge.getAttr("w") >= 1.0 / node.outEdges.size()) {
					// its influence to the neighbor
					double itsInf = (Double) edge.getAttr("w")
							* (Double) edge.dest.getAttr("score");
					double myInf = 0.0;
					for (Edge edge2 : edge.dest.outEdges) {// all the edges of
						// the neighbor
						if (edge2.dest.id == node.id) {// if it's "the node"
							// if ((Double) edge2.getAttr("w")
							// * (Double) node.getAttr("score") >= (Double)
							// edge2.dest
							// .getAttr("str")
							if ((Double) edge2.getAttr("w") >= 1.0 / edge2.dest.outEdges
									.size()) {// if
												// "the node"
												// is
												// important
								// enough to the neighbor
								myInf = (Double) edge2.getAttr("w")
										* (Double) node.getAttr("score");
							}
							break;
						}
					}
					if (itsInf > myInf) {
						amIRoot = false;
						break;
					} else if (itsInf == myInf) { // special case - fullmesh,
						// ring
						if (edge.dest.id > node.id) {
							amIRoot = false;
							break;
						}
					}
				}
			}
			if (amIRoot) {
				roots.add(node);
				node.putAttr("isRoot", true);
				String label = (String) node.getAttr("label");
				if (label == null)
					label = node.id + "";
				System.out.println(label + " is root!");
			}
		}

		/*
		 * for(int i=0;i<roots.size()-1;i++) { for(int j=i+1;j<roots.size();j++)
		 * { Node node1 = roots.get(i); Node node2 = roots.get(j); Edge edge =
		 * new Edge(node1,node2);
		 * 
		 * roots.get(i).outEdges.add(arg0) } }
		 */
		System.out.println("Number of leaders: " + roots.size());

		return roots.size();
	}

	public static double nCommonNodes(ArrayList<Edge> a, ArrayList<Edge> b) {
		double count = 0;
		int i = 0, j = 0;
		while (i < a.size() && j < b.size()) {
			if (a.get(i).dest.id == b.get(j).src.id) {
				count += Math.min((Double) a.get(i).getAttr("value"),
						(Double) b.get(j).getAttr("value"));
				i++;
				j++;
			} else if (a.get(i).dest.id > b.get(j).src.id) {
				j++;
			} else {
				i++;
			}
		}
		return count;
	}

	public static double nFractionsCommonNodes(ArrayList<Edge> a,
			ArrayList<Edge> b) {
		double count = 0;
		int i = 0, j = 0;
		while (i < a.size() && j < b.size()) {
			if (a.get(i).dest.id == b.get(j).src.id) {
				count += 1.0 / a.get(i).dest.outEdges.size();
				i++;
				j++;
			} else if (a.get(i).dest.id > b.get(j).src.id) {
				j++;
			} else {
				i++;
			}
		}
		return count;
	}

	public static void calcNodeRandomWalkScore(Graph g) {
		int niter = 1000;
		if (g.symmetric != true) {
			for (Node node : g.nodes) {
				node.putAttr("score", 1.0 / g.nodes.size());
				// node.putAttr("score", 1.0);
			}
			for (int iter = 0; iter < niter; iter++) {
				for (Node node : g.nodes) {
					node.putAttr("pr2", 0.0);
				}
				for (Node node : g.nodes) {
					for (Edge edge : node.outEdges) {
						Node node2 = edge.dest;
						node2.putAttr(
								"pr2",
								(Double) node2.getAttr("pr2")
										+ (Double) edge.getAttr("w")
										* (Double) node.getAttr("score"));
					}
				}

				double maxDiff = 0.0;
				for (Node node : g.nodes) {
					maxDiff = Math.max(
							maxDiff,
							Math.abs((Double) node.getAttr("pr2")
									- (Double) node.getAttr("score")));
					node.putAttr("score", (Double) node.getAttr("pr2"));
				}
				if (maxDiff < 1E-5) {
					break;
				}
			}
		} else {
			double ww = 0;
			for (Node node : g.nodes) {
				ww += (Double) node.getAttr("strength");
			}
			for (Node node : g.nodes) {
				node.putAttr("score", (Double) node.getAttr("strength") / ww);
			}
			// for (Node node : g.nodes) {
			// ww += (Double) node.getAttr("strengthBiased")
			// * node.outEdges.size();
			// }
			// for (Node node : g.nodes) {
			// node.putAttr("score",
			// (Double) node.getAttr("strengthBiased")
			// * node.outEdges.size() / ww);
			// }

			// RWIterations(g);
		}
	}

	public static void calcParentScores(Graph g) {
		for (Node node : g.nodes) {
			node.putAttr("score", 0.0);
		}
		int total = 0;
		for (Node node : g.nodes) {
			ArrayList<Node> parents = new ArrayList<Node>();
			double maxInf = 0.0;
			for (Edge edge : node.outEdges) {
				if ((Double) edge.getAttr("w") > maxInf) {
					maxInf = (Double) edge.getAttr("w");
					parents = new ArrayList<Node>();
					parents.add(edge.dest);
				} else if ((Double) edge.getAttr("w") == maxInf) {
					parents.add(edge.dest);
				}
			}
			for (Node node2 : parents) {
				total++;
				node2.putAttr("score", (Double) node2.getAttr("score") + 1.0
						/ parents.size());
			}
		}
		for (Node node : g.nodes) {
			node.putAttr("score", (Double) node.getAttr("score") / total);
		}
	}

	public static void RWIterations(Graph g) {
		double ww = 0.0;
		int nitern = 1000;
		for (Node node : g.nodes) {
			node.putAttr("score", 1.0 / g.nodes.size());
		}
		for (int i = 0; i < nitern; i++) {
			ww = 0.0;
			for (Node node : g.nodes) {
				double sb = 0.0;
				for (Edge edge : node.outEdges) {
					sb += (Double) edge.getAttr("weigth")
							* (Double) edge.dest.getAttr("score");
				}
				node.putAttr("strengthBiased", sb);
				ww += (Double) node.getAttr("strengthBiased")
						* (Double) node.getAttr("score");
			}
			for (Node node : g.nodes) {
				node.putAttr("score", (Double) node.getAttr("strengthBiased")
						* (Double) node.getAttr("score") / ww);
			}
		}
	}

	public static void calcEdgeScore(Graph g) {
		for (Node node : g.nodes) {
			if (node.getAttr("score") == null) {
				node.putAttr("score", 0.0);
			}
			double[] intersection = new double[node.outEdges.size()];
			double sumIntersect = 0;
			double degreeWeight = 0;
			for (int i = 0; i < node.outEdges.size(); i++) {
				Node dst = node.outEdges.get(i).dest;
				intersection[i] = nCommonNodes(node.outEdges, dst.inEdges)
						* 1.0 + (Double) node.outEdges.get(i).getAttr("value");
				sumIntersect += intersection[i];
				degreeWeight += (Double) node.outEdges.get(i).getAttr("value");
			}
			node.putAttr("strength", sumIntersect);
			node.putAttr("degreeWeight", degreeWeight);
			// annotate the edges with weight
			for (int i = 0; i < node.outEdges.size(); i++) {
				Edge edge = node.outEdges.get(i);
				double w = 0;
				w = (intersection[i] * 1.0) / sumIntersect;
				edge.putAttr("weigth", intersection[i] * 1.0);
				edge.putAttr("w", w);
			}
		}
	}

	private static class GroupMembership implements Comparable<GroupMembership> {
		public int id;
		public double involvement;

		public GroupMembership(int id, double involvement) {
			this.id = id;
			this.involvement = involvement;
		}

		public GroupMembership() {
			this.id = -1;
			this.involvement = 0;
		}

		@Override
		public int compareTo(GroupMembership gm) {
			return this.id - gm.id;
		}
	}
	
	private static double[] calcColors3(Graph g, ArrayList<ArrayList<Node>> groups,
			boolean printMembershipVectors) {
		double[] params = new double[2];
		int nleaders = groups.size();
		// color only the leaders, for the rest set 0 for each cluster
		int ind = 0;
		for (ArrayList<Node> group : groups) {
			for (Node node : group) {
				ArrayList<GroupMembership> cmap = new ArrayList<GroupMembership>();
				cmap.add(new GroupMembership(ind, 1.0));// the group color
				node.putAttr("cmap", cmap);
			}
			ind++;
		}

		int niter = 1000;
		double maxDiff = 0.0;
		//iterations for consesus dynamics
		for (int iter = 1; iter <= niter; iter++) {
			maxDiff = 0.0;
			for (Node node : g.nodes) {
				if (node.getAttr("isRoot") != null)// if it is a root, do not
					// color
					continue;
				double[] cmaparray = new double[nleaders];//temp array for fast access
				ArrayList<Integer> cmapids = new ArrayList<Integer>();//arraylist of used ids
				double totalInvolvement = 0.0;
				double degreeWeight = (Double)node.getAttr("degreeWeight");
				//for every neighbor
				for (Edge edge : node.outEdges) {
					Node neighbor = edge.dest;
					ArrayList<GroupMembership> cmapneighbor = (ArrayList<GroupMembership>) neighbor
							.getAttr("cmap");//neighbor's previous color
					if(cmapneighbor == null)//if not involved yet
						continue;
					if(cmapneighbor.size() == 0)//if not involved yet
						continue;
					double edgevalue = ((Double) edge.getAttr("value"))/degreeWeight;
					Iterator<GroupMembership> itr = cmapneighbor.iterator();
					//iterate neighbor's involvements
					while (itr.hasNext()) {
						GroupMembership gm = itr.next();
						cmaparray[gm.id] += gm.involvement*edgevalue;
						cmapids.add(gm.id);
					}
					totalInvolvement += edgevalue;
				}
				ArrayList<GroupMembership> newcmap = new ArrayList<GroupMembership>();//the new color
				Iterator<Integer> itr = cmapids.iterator();
				boolean[] cmaparrayids = new boolean[nleaders];//to check if some id has been accessed before
				double check = 0.0;
				while (itr.hasNext()) {
					Integer gid = itr.next();
					if(cmaparrayids[gid])
						continue;
					cmaparrayids[gid] = true;
					GroupMembership gm = new GroupMembership(gid, cmaparray[gid]/totalInvolvement);
					check += gm.involvement;
					newcmap.add(gm);
				}
				if((check < 0.99)&&(newcmap.size()>0))
					System.out.println("error with node " + node.id + " iteration " + iter);
				node.putAttr("newcmap", newcmap);
			}
			//check for convergence - to be optimized
			for(Node node : g.nodes){
				if(node.getAttr("isRoot")!=null)
					continue;
				ArrayList<GroupMembership> cmap = (ArrayList<GroupMembership>)node.getAttr("cmap");
				ArrayList<GroupMembership> newcmap = (ArrayList<GroupMembership>)node.getAttr("newcmap");
				if((newcmap == null)||(cmap == null)) {
					maxDiff = 1.0;
					break;
				}
				double[] cmaparray = new double[nleaders];
				double[] newcmaparray = new double[nleaders];
				ArrayList<Integer> ids = new ArrayList<Integer>();
				Iterator<GroupMembership> itr = cmap.iterator();
				while (itr.hasNext()) {
					GroupMembership gm = itr.next();
					cmaparray[gm.id] = gm.involvement;
					ids.add(gm.id);
				}
				itr = newcmap.iterator();
				while (itr.hasNext()) {
					GroupMembership gm = itr.next();
					newcmaparray[gm.id] = gm.involvement;
					ids.add(gm.id);
				}
				Iterator<Integer> itr2 = ids.iterator();
				boolean[] idsb = new boolean[nleaders];
				while (itr2.hasNext()) {
					Integer id = itr2.next();
					if(idsb[id])
						continue;
					idsb[id] = true;
					if(maxDiff < Math.abs(cmaparray[id]-newcmaparray[id]))
						maxDiff = Math.abs(cmaparray[id]-newcmaparray[id]);
				}
			}
			double count = 0;
			for (Node node : g.nodes) {
				if (node.getAttr("isRoot") == null){
					ArrayList<GroupMembership> newcmap = (ArrayList<GroupMembership>)node.getAttr("newcmap");
					if(newcmap!=null)
						node.putAttr("cmap", newcmap);
				}
				count += ((ArrayList<GroupMembership>)node.getAttr("cmap")).size();
			}
			//System.out.println("maxDiff: " + maxDiff);
			if (maxDiff < 1E-3) {
				params[0] = count/g.nodes.size();
				params[1] = iter;
				//System.out.println("average cmap size: " + count/g.nodes.size());
				//System.out.println("iter: " + iter);
				break;
			}
		}

		// for(Node node : g.nodes){
		// ArrayList<GroupMembership> cmap = (ArrayList<GroupMembership>)
		// node.getAttr("cmap");
		// System.out.print(cmap.size() + " ");
		// }
		// System.out.println("");

		printMembershipVectors = false;
		if (printMembershipVectors) {
			// printing of the average variance and colors
			for (Node node : g.nodes) {
				double av = 0.0;
				ArrayList<GroupMembership> cmap = (ArrayList<GroupMembership>) node
						.getAttr("cmap");
				Iterator<GroupMembership> itr = cmap.iterator();
				while (itr.hasNext()) {
					GroupMembership gm = itr.next();
					av += (gm.involvement - 1.0 / cmap.size())
							* (gm.involvement - 1.0 / cmap.size());
				}
				node.putAttr("av", av);
			}
			SortNodesByAttribute(g, "av", false);
			for (Node node : g.nodes) {
				String label = (String) node.getAttr("label");
				if (label == null)
					label = node.id + "";
				String ss = "[";
				ArrayList<GroupMembership> cmap = (ArrayList<GroupMembership>) node
						.getAttr("cmap");
				double[] cmaparray = new double[nleaders]; 
				Iterator<GroupMembership> itr = cmap.iterator();
				while(itr.hasNext()){
					GroupMembership gm = itr.next();
					cmaparray[gm.id] = gm.involvement;
				}
				for (int i = 0; i < nleaders; i++) {
					ss += " " + cmaparray[i];
				}
				ss += " ]";
				System.out.println(label + " - av: "
						+ node.getAttr("av").toString() + " - " + ss);
			}
		}
		return params;
	}

	private static double[] calcColors(Graph g, ArrayList<ArrayList<Node>> groups,
			boolean printMembershipVectors) {
		double[] params = new double[2];
		int nleaders = groups.size();
		// color only the leaders, for the rest set 0 for each cluster
		int ind = 0;
		for (ArrayList<Node> group : groups) {
			for (Node node : group) {
				ArrayList<GroupMembership> cmap = new ArrayList<GroupMembership>();
				cmap.add(new GroupMembership(ind, 1.0));// the group color
				node.putAttr("cmap", cmap);
			}
			ind++;
		}

		int niter = 1000;
		double maxDiff = 0.0;
		double thresholdInvolvement = 0.05;
		//iterations for consesus dynamics
		for (int iter = 1; iter <= niter; iter++) {
			maxDiff = 0.0;
			for (Node node : g.nodes) {
				if (node.getAttr("isRoot") != null)// if it is a root, do not
					// color
					continue;
				ArrayList<GroupMembership> cmap = (ArrayList<GroupMembership>) node
						.getAttr("cmap");//the previous color
				if(cmap == null)
					cmap = new ArrayList<GroupMembership>();
				ArrayList<GroupMembership> newcmap = new ArrayList<GroupMembership>();//the new color
				double totalInvolvement = 0.0;
				//for every neighbor
				for (Edge edge : node.outEdges) {
					Node neighbor = edge.dest;
					ArrayList<GroupMembership> cmapneighbor = (ArrayList<GroupMembership>) neighbor
							.getAttr("cmap");//neighbor's previous color
					if(cmapneighbor == null)
						continue;
					//double neighborscore = (Double) neighbor.getAttr("score");
					double edgescore = (Double) edge.getAttr("w");
					Iterator<GroupMembership> itr = cmapneighbor.iterator();
					//iterate its involvements
					while (itr.hasNext()) {
						GroupMembership gm = itr.next();
						int index = Collections.binarySearch(newcmap, gm);//find its place
						if (index >= 0) {//if it is found
							newcmap.get(index).involvement += edgescore*gm.involvement;
							totalInvolvement += edgescore*gm.involvement;
						} else {
							newcmap.add(-index - 1, new GroupMembership(gm.id,
									edgescore*gm.involvement));
							totalInvolvement += edgescore*gm.involvement;
						}
					}
				}
				Iterator<GroupMembership> itr = newcmap.iterator();
				double removedInvolvement = 0.0;
				ArrayList<GroupMembership> removedGroups = new ArrayList<GroupMembership>();
				while (itr.hasNext()) {
					GroupMembership gm = itr.next();
					gm.involvement /= totalInvolvement;
					// if ((gm.involvement < thresholdInvolvement) && (iter >
					// 5)) {
					// removedInvolvement += gm.involvement * totalInvolvement;
					// removedGroups.add(gm);
					// } else {
					int index = Collections.binarySearch(cmap, gm);
					double cmapinv = 0.0;
					if (index >= 0)
						cmapinv = cmap.get(index).involvement;
					if (Math.abs(gm.involvement - cmapinv) > maxDiff)
						maxDiff = Math.abs(gm.involvement - cmapinv);
					// }
				}
				// //if (removedInvolvement > 0.0) {
				// for (GroupMembership gm : removedGroups)
				// newcmap.remove(gm);
				// itr = newcmap.iterator();
				// while (itr.hasNext()) {
				// GroupMembership gm = itr.next();
				// gm.involvement = gm.involvement * totalInvolvement
				// / (totalInvolvement - removedInvolvement);
				// int index = Collections.binarySearch(cmap, gm);
				// double cmapinv = 0.0;
				// if (index >= 0)
				// cmapinv = cmap.get(index).involvement;
				// if (Math.abs(gm.involvement - cmapinv) > maxDiff)
				// maxDiff = Math.abs(gm.involvement - cmapinv);
				// }
				// //}
				node.putAttr("newcmap", newcmap);
			}
			double count = 0;
			for (Node node : g.nodes) {
				if (node.getAttr("isRoot") == null)
					node.putAttr("cmap", node.getAttr("newcmap"));
				count += ((ArrayList<GroupMembership>)node.getAttr("cmap")).size();
			}
			// System.out.println("maxDiff: " + maxDiff);
			if (maxDiff < 1E-5) {
				params[0] = count/g.nodes.size();
				params[1] = iter;
				//System.out.println("average cmap size: " + count/g.nodes.size());
				//System.out.println("iter: " + iter);
				break;
			}
		}

		// for(Node node : g.nodes){
		// ArrayList<GroupMembership> cmap = (ArrayList<GroupMembership>)
		// node.getAttr("cmap");
		// System.out.print(cmap.size() + " ");
		// }
		// System.out.println("");

		//printMembershipVectors = false;
		if (printMembershipVectors) {
			// printing of the average variance and colors
			for (Node node : g.nodes) {
				double av = 0.0;
				ArrayList<GroupMembership> cmap = (ArrayList<GroupMembership>) node
						.getAttr("cmap");
				Iterator<GroupMembership> itr = cmap.iterator();
				while (itr.hasNext()) {
					GroupMembership gm = itr.next();
					av += (gm.involvement - 1.0 / cmap.size())
							* (gm.involvement - 1.0 / cmap.size());
				}
				node.putAttr("av", av);
			}
			SortNodesByAttribute(g, "av", false);
			for (Node node : g.nodes) {
				String label = (String) node.getAttr("label");
				if (label == null)
					label = node.id + "";
				String ss = "[";
				ArrayList<GroupMembership> cmap = (ArrayList<GroupMembership>) node
						.getAttr("cmap");
				Iterator<GroupMembership> itr = cmap.iterator();
				GroupMembership gm = new GroupMembership();
				if (itr.hasNext())
					gm = itr.next();
				for (int i = 0; i < nleaders; i++) {
					if (gm.id > -1) {
						if (gm.id == i) {
							ss += " " + gm.involvement;
							if (itr.hasNext())
								gm = itr.next();
							else
								gm = new GroupMembership();
						} else
							ss += " 0.0";
					} else
						ss += " 0.0";
				}
				ss += " ]";
				System.out.println(label + " - av: "
						+ node.getAttr("av").toString() + " - " + ss);
			}
		}
		return params;
	}

	private static void calcColors2(Graph g, ArrayList<ArrayList<Node>> groups,
			boolean print) {
		int nleaders = groups.size();
		// color only the leaders, for the rest set 1/nleaders for each cluster
		for (Node node : g.nodes) {
			double[] cmap = new double[nleaders];
			if (node.getAttr("isRoot") != null) {
				for (int i = 0; i < nleaders; i++) {
					if (groups.get(i).contains(node))
						cmap[i] = 1.0;// the group color
					else
						cmap[i] = 0.0;
				}
			} else {
				//cmap[0] = 1.0;
				for (int i = 0; i < nleaders; i++) {
					cmap[i] = 1.0 / nleaders;
				}
			}
			node.putAttr("cmap", cmap);
		}

		for (Node node : g.nodes) {
			double total = 0.0;
			for (Edge edge : node.outEdges) {
				Node neighbor = edge.dest;
				total += (Double) edge.getAttr("w")
						* (Double) neighbor.getAttr("score");
			}
			node.putAttr("nw", total);
		}
		int niter = 1000;
		double maxDiff = 0.0;
		for (int iter = 1; iter <= niter; iter++) {
			maxDiff = 0.0;
			for (Node node : g.nodes) {
				if (node.getAttr("isRoot") != null)// if it is a root, do not
					// color
					continue;
				double[] cmap = (double[]) node.getAttr("cmap");
				double[] newcmap = new double[nleaders];
				for (int i = 0; i < nleaders; i++) {
					newcmap[i] = 0.0;
				}
				for (Edge edge : node.outEdges) {
					Node neighbor = edge.dest;
					double[] cmapneighbor = (double[]) neighbor.getAttr("cmap");
					double neighborscore = (Double) neighbor.getAttr("score");
					double edgescore = (Double) edge.getAttr("w");
					double edgevalue = (Double) edge.getAttr("value");
					for (int i = 0; i < nleaders; i++) {
						double temp = cmapneighbor[i];
						// temp *=
						// (Double)edge.getAttr("value")/(Double)node.getAttr("degreeWeight");
						// temp *= edgescore;
						// temp *= neighborscore;
						newcmap[i] += edgevalue*temp;
					}
				}
				for (int i = 0; i < nleaders; i++) {
					double total = (Double) node.getAttr("nw");
					total = node.outEdges.size();
					total = (Double)node.getAttr("degreeWeight");
					newcmap[i] /= total;
					if (Math.abs(newcmap[i] - cmap[i]) > maxDiff)
						maxDiff = Math.abs(newcmap[i] - cmap[i]);
				}
				node.putAttr("newcmap", newcmap);
			}
			for (Node node : g.nodes) {
				if (node.getAttr("isRoot") == null)
					node.putAttr("cmap", node.getAttr("newcmap"));
			}
			if (maxDiff < 1E-3) {
				if (print)
					System.out.println("iter: " + iter);
				break;
			}
		}

		print = false;
		if (print) {
			// printing of the average variance and colors
			for (Node node : g.nodes) {
				double av = 0.0;
				double[] cmap = (double[]) node.getAttr("cmap");
				for (int i = 0; i < nleaders; i++) {
					av += (cmap[i] - 1.0 / nleaders)
							* (cmap[i] - 1.0 / nleaders);
				}
				node.putAttr("av", av);
			}
			SortNodesByAttribute(g, "av", false);
			for (Node node : g.nodes) {
				String label = (String) node.getAttr("label");
				if (label == null)
					label = node.id + "";
				String ss = "[";
				for (int i = 0; i < ((double[]) node.getAttr("cmap")).length; i++)
					ss += " " + ((double[]) node.getAttr("cmap"))[i];
				ss += " ]";
				System.out.println(label + " - av: "
						+ node.getAttr("av").toString() + " - " + ss);
			}
		}
	}

	private static void calcColors(Graph g, int nleaders) {
		int colorIndex = 0;
		// color only the leaders, for the rest set 1/nleaders for each cluster
		for (Node node : g.nodes) {
			double[] cmap = new double[nleaders];
			if (node.getAttr("isRoot") != null) {
				for (int i = 0; i < nleaders; i++) {
					cmap[i] = 0.0;
				}
				cmap[colorIndex++] = 1.0;
			} else {
				for (int i = 0; i < nleaders; i++) {
					cmap[i] = 1.0 / nleaders;
				}
			}
			node.putAttr("cmap", cmap);
		}

		for (Node node : g.nodes) {
			double total = 0.0;
			for (Edge edge : node.outEdges) {
				Node neighbor = edge.dest;
				total += (Double) edge.getAttr("w")
						* (Double) neighbor.getAttr("score");
			}
			node.putAttr("nw", total);
		}
		int niter = 1000;
		double maxDiff = 0.0;
		for (int iter = 1; iter <= niter; iter++) {
			maxDiff = 0.0;
			for (Node node : g.nodes) {
				if (node.getAttr("isRoot") != null)// if it is a root, do not
					// color
					continue;
				double[] cmap = (double[]) node.getAttr("cmap");
				double[] newcmap = new double[nleaders];
				for (int i = 0; i < nleaders; i++) {
					newcmap[i] = 0.0;
				}
				for (Edge edge : node.outEdges) {
					Node neighbor = edge.dest;
					double[] cmapneighbor = (double[]) neighbor.getAttr("cmap");
					double neighborscore = (Double) neighbor.getAttr("score");
					double edgescore = (Double) edge.getAttr("w");
					for (int i = 0; i < nleaders; i++) {
						double temp = cmapneighbor[i];
						// temp *=
						// (Double)edge.getAttr("value")/(Double)node.getAttr("degreeWeight");
						// temp *= edgescore;
						// temp *= neighborscore;
						newcmap[i] += temp;
					}
				}
				for (int i = 0; i < nleaders; i++) {
					double total = (Double) node.getAttr("nw");
					total = node.outEdges.size();
					newcmap[i] /= total;
					if (Math.abs(newcmap[i] - cmap[i]) > maxDiff)
						maxDiff = Math.abs(newcmap[i] - cmap[i]);
				}
				node.putAttr("newcmap", newcmap);
			}
			for (Node node : g.nodes) {
				if (node.getAttr("isRoot") == null)
					node.putAttr("cmap", node.getAttr("newcmap"));
			}
			if (maxDiff < 1E-3) {
				break;
			}
		}

		// printing of the average variance and colors
		for (Node node : g.nodes) {
			double av = 0.0;
			double[] cmap = (double[]) node.getAttr("cmap");
			for (int i = 0; i < nleaders; i++) {
				av += (cmap[i] - 1.0 / nleaders) * (cmap[i] - 1.0 / nleaders);
			}
			node.putAttr("av", av);
		}
		SortNodesByAttribute(g, "av", false);
		for (Node node : g.nodes) {
			String label = (String) node.getAttr("label");
			if (label == null)
				label = node.id + "";
			String ss = "[";
			for (int i = 0; i < ((double[]) node.getAttr("cmap")).length; i++)
				ss += " " + ((double[]) node.getAttr("cmap"))[i];
			ss += " ]";
			System.out.println(label + " - av: "
					+ node.getAttr("av").toString() + " - " + ss);
		}
	}

	public static void LeaderProbability(Graph g) throws IOException,
			NumberFormatException, InterruptedException {
		int niter = 1000;
		for (Node node : g.nodes) {
			node.putAttr("score", 1.0 / g.nodes.size());
			// node.putAttr("score", 1.0);
		}
		for (int iter = 0; iter < niter; iter++) {
			for (Node node : g.nodes) {
				node.putAttr("qin", 0.0);
				node.putAttr("qout", 0.0);
			}
			for (Node node : g.nodes) {
				for (Edge edge : node.outEdges) {
					Node node2 = edge.dest;
					node2.putAttr(
							"qin",
							(Double) node2.getAttr("qin")
									+ (Double) edge.getAttr("w")
									* (Double) node.getAttr("score"));
					node.putAttr(
							"qout",
							(Double) node.getAttr("qout")
									+ (Double) edge.getAttr("w")
									* (Double) node2.getAttr("score"));
				}
			}

			for (Node node : g.nodes) {
				if ((Double) node.getAttr("qin") == 0
						&& (Double) node.getAttr("qout") == 0)
					node.putAttr("pr2", 0.0);
				else
					node.putAttr(
							"pr2",
							(Double) node.getAttr("qin")
									/ ((Double) node.getAttr("qin") + (Double) node
											.getAttr("qout")));
			}

			double maxDiff = 0.0;
			for (Node node : g.nodes) {
				maxDiff = Math.max(
						maxDiff,
						Math.abs((Double) node.getAttr("pr2")
								- (Double) node.getAttr("score")));
				node.putAttr("score", (Double) node.getAttr("pr2"));
			}
			if (maxDiff < 1E-5) {
				break;
			}
		}

		HierarchyCommunityDetection.SortNodesByAttribute(g, "score", true);
	}

	public static void LeaderProbabilityMain(int fileNumber,
			boolean makeSymmetric, boolean draw) throws IOException,
			NumberFormatException, InterruptedException {
		String filename = Files.files[fileNumber];
		long start = System.currentTimeMillis();
		Graph g;
		if (filename.endsWith(".gml"))
			g = Graph.readGraphGML("datasets/gml/" + filename, makeSymmetric);
		else if (filename.endsWith(".pjk"))
			g = Graph.readGraphPajek("datasets/pjk/" + filename, makeSymmetric);
		else
			g = Graph.readGraphEdgeList("datasets/edgeformat/" + filename,
					makeSymmetric);
		g.putAttr("filename", filename);
		long end = System.currentTimeMillis() - start;
		System.out.println("read:" + end + "ms");

		calcEdgeScore(g);
		LeaderProbability(g);
		if (draw) {
			jung.Test.drawGraph(g);
		}
	}

	public static void SortNodesByAttribute(Graph g, final String attribute,
			boolean print) {
		Collections.sort(g.nodes, new Comparator<Node>() {
			@Override
			public int compare(Node o1, Node o2) {
				Double d1 = (Double) o1.getAttr(attribute);
				Double d2 = (Double) o2.getAttr(attribute);
				if (d1 > d2) {
					return -1;
				} else if (d1 < d2) {
					return 1;
				} else {
					return 0;
				}
			}
		});
		if (print) {
			for (Node node : g.nodes) {
				System.out.println(node.id + " " + node.getAttr("label")
						+ " : " + node.getAttr(attribute));
			}
		}
	}

	public static void setDominantColorOnNodes(Graph g, int nleaders) {
		for (Node node : g.nodes) {
			double[] cmap = (double[]) node.getAttr("cmap");
			double max = 0.0;
			int maxIndex = -1;
			for (int i = 0; i < nleaders; i++) {
				if (max < cmap[i]) {
					max = cmap[i];
					maxIndex = i;
				}
			}
			for (int i = 0; i < nleaders; i++) {
				cmap[i] = 0.0;
			}
			cmap[maxIndex] = 1.0;
		}
	}
}
